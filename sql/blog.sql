/*
 Navicat Premium Data Transfer

 Source Server         : 本地数据库
 Source Server Type    : MySQL
 Source Server Version : 80018
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80018
 File Encoding         : 65001

 Date: 25/08/2022 10:44:25
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `commentabled` int(1) NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `first_picture` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `flag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `published` int(1) NOT NULL,
  `recommend` int(1) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `views` int(11) NULL DEFAULT NULL,
  `type_id` bigint(20) NULL DEFAULT NULL,
  `user_id` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FK292449gwg5yf7ocdlmswv9w4j`(`type_id`) USING BTREE,
  INDEX `FK8ky5rrsxh01nkhctmo7d48p82`(`user_id`) USING BTREE,
  CONSTRAINT `FK292449gwg5yf7ocdlmswv9w4j` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FK8ky5rrsxh01nkhctmo7d48p82` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES (2, 1, '### 问题描述\r\n设计一个国际象棋的马踏遍棋盘的演示程序。\r\n### 基本要求\r\n将马随机放在国际象棋的 8×8 棋盘 Board[0～7][0～7]的某个方格中，马按走棋规则进行移动。要求每个方格只进入一次，走遍棋盘上全部 64 个方格。编制非递归程序，求出马的行走路线，并按求出的行走路线，将数字 1，2，…，64依次填入一个 8×8 的方阵，输出之。\r\n### 使用回溯法实现\r\n```c\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#define maxSize 1000\r\nint Board[8][8] = { 0 };//0为走过，i为步数\r\nint Direction[2][9] = {\r\n	{0, -2 , -1, 1, 2, 2, 1, -1, -2},\r\n	{0, 1, 2, 2, 1, -1, -2, -2, -1}\r\n};\r\ntypedef struct {\r\n	int x;//行0~7\r\n	int y;//列0~7\r\n	int d;//已经探索过的方向数目（0~8）\r\n}Spot;\r\n//判断是否可行\r\nint Feasible(int x, int y) {\r\n	if ((0 <= x) && (x < 8) && (0 <= y) && (y < 8) && (Board[x][y] == 0)) {\r\n		return 1;\r\n	}\r\n	else\r\n	{\r\n		return 0;\r\n	}\r\n}\r\n//下一步\r\nint NextDirection(Spot Cur) {\r\n	int i, x, y;\r\n	for (i = Cur.d + 1; i <= 8; i++)\r\n	{\r\n		x = Cur.x + Direction[0][i];\r\n		y = Cur.y + Direction[1][i];\r\n		if (Feasible(x, y))\r\n		{\r\n			return i;\r\n		}\r\n	}\r\n	return 0;//当前位置点入栈，棋盘上cur点对应位置改成0，Step--\r\n}\r\n//栈\r\ntypedef struct {\r\n	Spot spot;\r\n	struct StackLnode* next;\r\n}StackLnode;\r\n//初始化\r\nvoid InitStackLnode(StackLnode* S) {\r\n	S->next = NULL;\r\n}\r\n//入栈\r\nSpot PushStackLnode(StackLnode* S, Spot e) {\r\n	StackLnode* p;\r\n	p = (StackLnode*)malloc(sizeof(StackLnode));\r\n	p->spot = e;\r\n	p->next = S->next;\r\n	S->next = p;\r\n}\r\n//出栈\r\nSpot PopStackLnode(StackLnode* S, Spot e) {\r\n	StackLnode* p;\r\n	p = S->next;\r\n	e = p->spot;\r\n	S->next = p->next;\r\n	free(p);\r\n	return e;\r\n}\r\nvoid Horse(int m, int n) {\r\n	StackLnode S;\r\n	int Step = 1;\r\n	InitStackLnode(&S);\r\n	int k;\r\n	Spot Cur, Next;//分别表示当前、下一位置点\r\n	Cur.x = m;\r\n	Cur.y = n;\r\n	Cur.d = 0;//没有开始探测\r\n	Board[Cur.x][Cur.y] = Step;\r\n	do\r\n	{\r\n		k = NextDirection(Cur);\r\n		if (k) {\r\n			Cur.d = k;\r\n			PushStackLnode(&S, Cur);\r\n			Next.x = Cur.x + Direction[0][k];\r\n			Next.y = Cur.y + Direction[1][k];\r\n			Next.d = 0;\r\n			Cur = Next;\r\n			Board[Cur.x][Cur.y] = (++Step);\r\n		}\r\n		else {\r\n			Step--;\r\n			Board[Cur.x][Cur.y] = 0;\r\n			Cur = PopStackLnode(&S, Cur);\r\n\r\n		}\r\n\r\n	} while (Step < 64);\r\n	//打印棋盘\r\n	int i, j;\r\n	for (i = 0; i < 8; i++)\r\n	{\r\n		for (j = 0; j < 8; j++) {\r\n			printf(\"%d\\t\", Board[i][j]);\r\n		}\r\n		printf(\"\\n\\n\");\r\n	}\r\n};\r\n\r\nvoid main()\r\n{\r\n	int m, n;\r\n	printf(\"请输入马在棋盘内的位置(0~7,两个数用逗号隔开)！：\");\r\n	scanf_s(\"%d,%d\", &m, &n);\r\n	if (m < 0 || m>7 || n < 0 || n>7) {\r\n		printf(\"位置错误！\");\r\n	}\r\n	else\r\n	{\r\n		printf(\"参数正确，调用函数！\\n\");\r\n		Horse(m, n);\r\n	}\r\n}\r\n```\r\n### 添加贪心算法后提升效率\r\n```c\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\nint Board[8][8] = { 0 };//0为走过，i为步数\r\ntypedef struct {\r\n	int x;//行0~7\r\n	int y;//列0~7\r\n	int d[9];//d[i]记录第i号方向是否已走过（0否， 1是）\r\n}Spot;\r\nint Direction[2][9] = {\r\n	{0, -2 , -1, 1, 2, 2, 1, -1, -2},\r\n	{0, 1, 2, 2, 1, -1, -2, -2, -1}\r\n};\r\nint Weight[8][8] = { 0 };//每个位置权值，1~8表示未被占用，9表示该点被占用\r\nint MinWt = 9;\r\n\r\n//栈\r\ntypedef struct {\r\n	Spot spot;\r\n	struct StackLnode* next;\r\n}StackLnode;\r\n//初始化\r\nvoid InitStackLnode(StackLnode* S) {\r\n	S->next = NULL;\r\n}\r\n//入栈\r\nvoid PushStackLnode(StackLnode* S, Spot e) {\r\n	StackLnode* p;\r\n	p = (StackLnode*)malloc(sizeof(StackLnode));\r\n	p->spot = e;\r\n	p->next = S->next;\r\n	S->next = p;\r\n}\r\n//出栈\r\nSpot PopStackLnode(StackLnode* S, Spot e) {\r\n	StackLnode* p;\r\n	p = (StackLnode*)malloc(sizeof(StackLnode));\r\n	p = S->next;\r\n	e = p->spot;\r\n	S->next = p->next;\r\n	free(p);\r\n	return e;\r\n}\r\n//判断是否可行\r\nint Feasible(int x, int y) {\r\n	if ((0 <= x) && (x < 8) && (0 <= y) && (y < 8) && (Board[x][y] == 0)) {\r\n		return 1;\r\n	}\r\n	else\r\n	{\r\n		return 0;\r\n	}\r\n}\r\n//贪心选择下一步\r\nint NextDirectionWeight(Spot Cur) {\r\n	int MinDirection, k;\r\n	int x, y;\r\n	MinDirection = 0;\r\n	MinWt = 9;\r\n	for (k = 1; k <= 8; k++)\r\n	{\r\n		if (Cur.d[k]) { continue; }\r\n		x = Cur.x + Direction[0][k];\r\n		y = Cur.y + Direction[1][k];\r\n		if (Feasible(x, y) && Weight[x][y] < MinWt)\r\n		{\r\n			MinWt = Weight[x][y];\r\n			MinDirection = k;\r\n		}\r\n	}\r\n	return MinDirection;\r\n};\r\n//权值\r\nvoid InitWeight() {//初始化，计算每个点的权值\r\n	int i, j, k, count = 0;\r\n	int x, y;\r\n	Spot S;\r\n	for (i = 0; i < 8; i++)\r\n	{\r\n		for (j = 0; j < 8; j++) {\r\n			S.x = i;\r\n			S.y = j;\r\n			for (k = 1; k <= 8; k++)\r\n			{\r\n				x = S.x + Direction[0][k];\r\n				y = S.y + Direction[1][k];\r\n				if (Feasible(x, y))\r\n				{\r\n					count++;\r\n				}\r\n			}\r\n			Weight[i][j] = count;\r\n			count = 0;\r\n		}\r\n	}\r\n};\r\n\r\nvoid SetWeight(int x, int y) {\r\n	int i,a,b;\r\n	Weight[x][y] = 9;\r\n	for (i = 1; i <= 8; i++)\r\n	{\r\n		a = x + Direction[0][i];\r\n		b = y + Direction[1][i];\r\n		if (Feasible(a, b))\r\n		{\r\n			Weight[a][b]--;\r\n		}\r\n	}\r\n};\r\nvoid  UnSetWeight(int x,int y) {\r\n	int i,k,a,b,count=0;\r\n	Weight[x][y] = 0;\r\n	for (i = 1; i <= 8; i++)\r\n	{\r\n		a = x + Direction[0][i];\r\n		b = y + Direction[1][i];\r\n		if (Feasible(a, b))\r\n		{\r\n			count++;\r\n		}\r\n	}\r\n	Weight[x][y] = count;\r\n	for (k = 1; k <= 8; k++)\r\n	{\r\n		a = x + Direction[0][k];\r\n		b = y + Direction[1][k];\r\n		if (Feasible(a, b))\r\n		{\r\n			Weight[a][b]++;\r\n		}\r\n	}\r\n};\r\nvoid Horse(int m, int n) {\r\n	StackLnode S;\r\n	int Step = 1;\r\n	InitStackLnode(&S);\r\n	InitWeight();\r\n	int i,k;\r\n	Spot Cur, Next;//分别表示当前、下一位置点\r\n	Cur.x = m;\r\n	Cur.y = n;\r\n	for ( i = 0; i < 9; i++)\r\n	{\r\n		Cur.d[i] = 0;//没有开始探测\r\n	}\r\n	Board[Cur.x][Cur.y] = Step;\r\n	SetWeight(Cur.x, Cur.y);\r\n	do\r\n	{\r\n		k = NextDirectionWeight(Cur);\r\n		if (k) {\r\n			Cur.d[k] = 1;\r\n			PushStackLnode(&S, Cur);\r\n			Next.x = Cur.x + Direction[0][k];\r\n			Next.y = Cur.y + Direction[1][k];\r\n			for (i = 0; i < 9; i++)\r\n			{\r\n				Next.d[i] = 0;//没有开始探测\r\n			}\r\n			Cur = Next;\r\n			Board[Cur.x][Cur.y] = (++Step);\r\n			SetWeight(Cur.x, Cur.y);\r\n		}\r\n		else {\r\n			Step--;\r\n			Board[Cur.x][Cur.y] = 0;\r\n			Cur = PopStackLnode(&S, Cur);\r\n			UnSetWeight(Cur.x, Cur.y);\r\n		}\r\n\r\n	} while (Step < 64);\r\n	//打印棋盘\r\n	int  j;\r\n	for (i = 0; i < 8; i++)\r\n	{\r\n		for (j = 0; j < 8; j++) {\r\n			printf(\"%d\\t\", Board[i][j]);\r\n		}\r\n		printf(\"\\n\\n\");\r\n	}\r\n};\r\n\r\nvoid main() {\r\n	int m, n;\r\n	printf(\"使用了贪心算法\\n\");\r\n	printf(\"请输入马在棋盘内的位置(0~7,两个数用逗号隔开)！：\");\r\n	scanf_s(\"%d,%d\", &m, &n);\r\n	if (m < 0 || m>7 || n < 0 || n>7) {\r\n		printf(\"位置错误！\");\r\n	}\r\n	else\r\n	{\r\n		printf(\"参数正确，调用函数！\\n\\n\");\r\n		Horse(m, n);\r\n	}\r\n}\r\n```\r\n', '2021-07-18 11:14:06', '用贪心算法和回溯法解决马踏棋盘问题', 'https://s.cn.bing.net/th?id=OIP-C.RH6yRIuTW_zAI-7Z7bj9bAHaES&w=328&h=190&c=8&rs=1&qlt=90&o=6&dpr=1.5&pid=3.1&rm=2', '原创', 1, 1, '马踏棋盘', '2022-03-23 22:04:46', 88, 3, 1);
INSERT INTO `t_blog` VALUES (4, 1, '## 一、安装宝塔面板\r\n- 使用服务器命令行安装宝塔面板Centos安装脚本：\r\n\r\n\r\n        yum install -y wget && wget -O install.sh http://download.bt.cn/install/install_6.0.sh && sh install.sh\r\n- 一路确认等待安装完毕\r\n-  进入宝塔面板\r\n- 按照推荐安装环境就好了，还要安装Tomcat8\r\n\r\n## 二、安装Java环境：\r\n\r\n- 1 下载jdk：\r\n\r\n        yum install java-1.8.0-openjdk java-1.8.0openjdk-devel\r\n\r\n- 2 配置jdk环境变量\r\n    \r\n        vim /etc/profile\r\n	\r\n- 3 进入文本编辑状态下，光标走到文件最后一行末尾（shift+g 快速定位到文件的最下方），键盘按下：i（英文状态）\r\n\r\n        export JAVA_HOME=/usr/lib/jvm/jdk1.8.0.171\r\n        export JRE_HOME=/$JAVA_HOME/jre\r\n        export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\r\n        export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\r\n\r\n- 输入：wq保存退出\r\n\r\n- 4 让环境变量生效\r\n\r\n        source /etc/profile\r\n- 5 检查JDK是否安装成功，如果出现了版本信息就是安装成功了\r\n\r\n        java -version\r\n## 三、进入Tomcat\r\n将需要的文件放入Tomcat的webapps目录下就可以访问\r\n访问路径：\r\n\r\n\r\n\r\n        http://服务器:Tomcat运行的端口/某某文件\r\n\r\n\r\n\r\n\r\n', '2021-07-23 16:59:11', '引用放在服务器图片', 'https://s.cn.bing.net/th?id=OIP-C.rHuc8SKa0wLVwCqqA27uIwHaEt&w=313&h=199&c=8&rs=1&qlt=90&o=6&dpr=1.5&pid=3.1&rm=2', '原创', 1, 0, '如何从服务器引用图片？', '2022-03-23 22:04:22', 71, 2, 1);
INSERT INTO `t_blog` VALUES (5, 1, '## 问题描述\r\n以一个 M×N 的长方阵表示迷宫，0 和 1 分别表示迷宫中的通路和障碍。设计一个程序，对任意设定的迷宫，求出一条从入口到出口的通路，或得出没有通路的结论。\r\n## 基本要求\r\n首先实现一个以链表作存储结构的栈类型，然后编写一个求解迷宫的非递归程序。求得的通路以三元组（i，j，d）的形式输出，其中：（i，j）指示迷宫中的一个坐标，d 表示走到下一坐标的方向。如：对于下列数据的迷宫，输出一条通路为：（1，1，1），（1，2，2），（2，2，2），（3，2，3），（3，1，2）等\r\n## 使用方法回溯法\r\n用到栈来存储节点位置信息，包括所在位置以及移动的方向。\r\n```c\r\n#include <stdio.h>\r\n#include <time.h>\r\nint Maze[10][9] = { 0 };\r\ntypedef struct {\r\n	int x;//行\r\n	int y;//列\r\n	int d;//探索过的方向\r\n} Spot;\r\nint Direction[2][5] = { {0,0,1,0,-1},{0,1,0,-1,0} };//四个方向\r\n//位置是否符合\r\nint Feasible(int x, int y) {\r\n	if (1 <= x && x <= 9&& 1<= y && y <= 8 && Maze[x][y] == 0)\r\n	{\r\n		return 1;\r\n	}\r\n	else\r\n	{\r\n		return 0;\r\n	}\r\n }\r\n//下一步\r\nint NextDirectoin(Spot Cur) {\r\n	int i, x, y;\r\n	for ( i = Cur.d+1; i <=4; i++)\r\n	{\r\n		x = Cur.x + Direction[0][i];\r\n		y = Cur.y + Direction[1][i];\r\n		if (Feasible(x,y))\r\n		{\r\n			return i;\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n//链栈\r\ntypedef Spot ElemType;\r\ntypedef struct {\r\n	ElemType data;\r\n	struct StackLnode* next;\r\n}StackLnode;\r\n//初始化\r\nint InitStackLnode(StackLnode* S) {\r\n	S->next = NULL;\r\n	return 1;\r\n}\r\n//入栈\r\nvoid PushStackLnode(StackLnode* S, Spot e) {\r\n	StackLnode* p = (StackLnode*)malloc(sizeof(StackLnode));\r\n	p->data = e;\r\n	p->next = S->next;\r\n	S->next = p;\r\n}\r\n//出栈\r\nvoid PopStackLnode(StackLnode* S, ElemType* e) {\r\n	if (S->next == NULL)\r\n	{\r\n		return ;\r\n	}\r\n	StackLnode* p;\r\n	p = S->next;\r\n	*e = p->data;\r\n	S->next = p->next;\r\n	free(p);\r\n}\r\n//判断栈是否空\r\nint IsEmpty(StackLnode* S) {\r\n	if (S->next == NULL)\r\n	{\r\n		return 1;\r\n	}\r\n	else {\r\n		return 0;\r\n	}\r\n}\r\n//判断是否到达终点\r\nint IsFinsh(Spot Cur,Spot End) {\r\n	if (Cur.x==End.x && Cur.y == End.y)\r\n	{\r\n		return 1;\r\n	}\r\n	else\r\n	{\r\n		return 0;\r\n	}\r\n};\r\nvoid SearchPath() {\r\n	int k,i;\r\n	StackLnode C,L;\r\n	L.next = NULL;\r\n	InitStackLnode(&C);\r\n	Spot Start, End;\r\n	Start.x = 1;\r\n	Start.y = 1;\r\n	End.x = 9;\r\n	End.y = 8;\r\n	Spot Cur, Next;\r\n	Cur = Start;\r\n	Cur.d = 0;\r\n	while (!IsFinsh(Cur,End))\r\n	{\r\n		k = NextDirectoin(Cur);\r\n		if (k)\r\n		{\r\n			Maze[Cur.x][Cur.y] = 2;\r\n			Cur.d = k;\r\n			Next.x = Cur.x + Direction[0][k];\r\n			Next.y = Cur.y + Direction[1][k];\r\n			Next.d = 0;\r\n			PushStackLnode(&C, Cur);\r\n			Cur = Next;\r\n		}\r\n		else {\r\n			if (IsEmpty(&C))\r\n			{\r\n				printf(\"没有通路！！！\");\r\n				break;\r\n			}\r\n			else\r\n			{\r\n				Maze[Cur.x][Cur.y] = 3;\r\n				PopStackLnode(&C, &Cur);\r\n			}\r\n		}\r\n	}\r\n	//打印通路\r\n	Spot s;\r\n	StackLnode* p;\r\n	while (C.next != NULL)\r\n	{\r\n		PopStackLnode(&C, &s);\r\n		PushStackLnode(&L, s);\r\n	}\r\n	p = L.next;\r\n	i = 0;\r\n	while (p!=NULL)\r\n	{\r\n		printf(\"(%d,%d,%d) \", p->data.x, p->data.y, p->data.d);\r\n		p = p->next;\r\n		i++;\r\n		if (i%5==0)\r\n		{\r\n			printf(\"\\n\");\r\n		}\r\n	}\r\n\r\n};\r\n\r\nvoid show() {\r\n	int i, j,k;\r\n	for ( k = 0; k < 9; k++)\r\n	{\r\n		printf(\"%d\\t\", k);\r\n	}\r\n	printf(\"\\n\\n\");\r\n	for ( i = 1; i < 10; i++)\r\n	{\r\n		printf(\"%d\\t\", i);\r\n		for (j = 1; j < 9; j++) {\r\n			if (i == 9 && j == 8)\r\n			{\r\n				printf(\"终点\");\r\n				break;\r\n			}\r\n			if (Maze[i][j]==1)\r\n			{\r\n				printf(\"障碍\\t\");\r\n			}\r\n			else if (Maze[i][j] == 2)\r\n			{\r\n				printf(\"路\\t\");\r\n			}\r\n			else if (Maze[i][j] == 3)\r\n			{\r\n				printf(\"<\\t\");\r\n			}\r\n			else\r\n			{\r\n				printf(\"0\\t\");\r\n			}\r\n		}\r\n		printf(\"\\n\\n\");\r\n	}\r\n\r\n}\r\nvoid main() {\r\n	srand((unsigned)time(NULL));//srand()就是给rand()提供种子seed \r\n	int i, j;\r\n	for ( i = 2; i < 9; i+=1)\r\n	{\r\n		for (j = 2; j <= 8; j += 1) {\r\n			Maze[i][j] = rand() % 2;\r\n		}\r\n	}\r\n	SearchPath();\r\n	printf(\"\\n起点已设置为（0，0）（“路”代表通路，<代表回溯过的路径，“障碍”代表阻碍，0代表从未到过）（障碍物位置是随机生成的！）\\n\");\r\n	show();\r\n}\r\n```\r\n', '2021-07-23 21:28:07', '回溯法解决迷宫问题', 'https://pic3.zhimg.com/80/v2-13dcec49a7aaa5dfcdbc215a03d2fd6b_1440w.jpg', '原创', 1, 1, '迷宫问题', '2022-03-23 22:03:09', 66, 3, 1);
INSERT INTO `t_blog` VALUES (6, 1, '```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n#include <windows.h>\r\n#define maxSize 120\r\n#define  EQ(a, b)   ((a)==(b))\r\n#define  LT(a, b)   ((a)<(b))\r\n#define  LQ(a, b)   ((a)<=(b))\r\n#define TRUE 1\r\n#define FALSE 0\r\nint len = 1;\r\nint count = 1;\r\nint compareCount;\r\nint i;\r\ntypedef int keyType;\r\ntypedef int status;\r\ntypedef struct BSTNode {\r\n	keyType key;\r\n	struct BSTNode* Lchild, * Rchild;\r\n}BSTNode;\r\ntypedef struct RecType {\r\n	keyType key;\r\n}RecType;\r\ntypedef struct ssTable {\r\n	RecType elem[maxSize];\r\n	int length;\r\n}ssTable;\r\ntypedef struct IndexType {\r\n	keyType maxkey;\r\n	int startpos;\r\n}Index;\r\n//顺序查找\r\nstatus seqSearch(ssTable  ST, keyType key)\r\n{\r\n	int p;\r\n	compareCount = 0;\r\n	ST.elem[0].key = key;    /*  设置监视哨兵,失败返回0  */\r\n	for (p = ST.length; !EQ(ST.elem[p].key, key); p--) { compareCount++; }\r\n	printf(\"顺序查找比较次数：%d \", compareCount);\r\n	return(p);\r\n}\r\n//折半查找\r\nint  BinSearch(ssTable  ST, keyType  key)\r\n{\r\n	int  Low = 1, High = ST.length, Mid;\r\n	compareCount = 0;\r\n	while (Low <= High)\r\n	{\r\n		Mid = (Low + High) / 2;\r\n		if (EQ(ST.elem[Mid].key, key)) {\r\n			printf(\"折半查找比较次数：%d \", compareCount);\r\n			return(Mid);\r\n		}\r\n		else if (LT(ST.elem[Mid].key, key)) {\r\n			compareCount++;\r\n			Low = Mid + 1;\r\n		}\r\n		else {\r\n			compareCount++;\r\n			High = Mid - 1;\r\n		}\r\n\r\n	}\r\n	return(0);      /*   查找失败  */\r\n}\r\n//插值查找\r\nint  InsertionSearch(ssTable  ST, keyType  key)\r\n{\r\n	int  Low = 1, High = ST.length, Mid;\r\n	compareCount = 0;\r\n	while (Low <= High)\r\n	{\r\n		Mid = Low + ((High - Low) / (ST.elem[High].key - ST.elem[Low].key)) * (key - ST.elem[Low].key);\r\n		if (EQ(ST.elem[Mid].key, key)) {\r\n			printf(\"插值查找比较次数：%d \", compareCount);\r\n			return(Mid);\r\n		}\r\n		else if (LT(ST.elem[Mid].key, key)) {\r\n			Low = Mid + 1;\r\n			compareCount++;\r\n		}\r\n		else {\r\n			High = Mid - 1;\r\n			compareCount++;\r\n		}\r\n	}\r\n	return(0);      /*   查找失败  */\r\n}\r\n//斐波那契查找\r\nvoid fibonacci(int* f)    //构建斐波那契序列\r\n{\r\n	f[0] = 1;\r\n	f[1] = 1;\r\n	for (i = 2; i < maxSize; ++i)\r\n		f[i] = f[i - 2] + f[i - 1];\r\n}\r\nint FibSearch(ssTable a, int key, int n)\r\n{\r\n	int low = 0, high = n - 1;\r\n	int mid = 0;\r\n	int k = 0;\r\n	int F[maxSize];\r\n	compareCount = 0;\r\n	fibonacci(F);\r\n	while (n > F[k] - 1) //计算出n在斐波那契中的位置\r\n		++k;\r\n	for (i = n; i < F[k] - 1; ++i) //把数组补全，使用a[n-1]\r\n		a.elem[i].key = a.elem[high].key;\r\n	while (low <= high) {\r\n		mid = low + F[k - 1] - 1;  //根据斐波那契数列进行黄金分割\r\n		if (a.elem[mid].key > key) {\r\n			compareCount++;\r\n			high = mid - 1;\r\n			k = k - 1;\r\n		}\r\n		else if (a.elem[mid].key < key) {\r\n			compareCount++;\r\n			low = mid + 1;\r\n			k = k - 2;\r\n		}\r\n		else {\r\n			if (mid <= high) //如果为真则找到相应的位置\r\n			{\r\n				printf(\"斐波那契查找比较次数：%d \", compareCount);\r\n				return mid;\r\n			}\r\n			else\r\n				return 0;\r\n		}\r\n	}\r\n	return 0;\r\n}\r\n//分块查找\r\nint Block_search(ssTable ST, Index ind[], keyType key, int n, int b)\r\n/*  在分块索引表中查找关键字为key的记录 */\r\n/*表长为n ，块数为b */\r\n{\r\n	int i = 0, j;\r\n	compareCount = 0;\r\n	while ((i < b) && LT(ind[i].maxkey, key)) {\r\n		compareCount++;\r\n		i++;\r\n	}\r\n	if (i > b) {\r\n		printf(\"\\nNot found\");   return(0);\r\n	}\r\n	j = ind[i].startpos;\r\n	while ((j < n) && LQ(ST.elem[j].key, ind[i].maxkey))\r\n	{\r\n		compareCount++;\r\n		if (EQ(ST.elem[j].key, key)) {\r\n			break;\r\n		}\r\n		j++;\r\n	}     /*  在块内查找  */\r\n	if (j > n || !EQ(ST.elem[j].key, key))\r\n	{\r\n		j = 0;\r\n		printf(\"\\nNot found\");\r\n	}\r\n	printf(\"分块查找比较次数：%d \", compareCount);\r\n	return(j);\r\n}\r\n//冒泡排序\r\nvoid BubbleSort(ssTable* L)\r\n{\r\n	int j, k, flag;\r\n	for (j = 1; j <= L->length; j++)       /*   共有n-1趟排序   */\r\n	{\r\n		flag = TRUE;\r\n		for (k = 1; k <= L->length - j; k++)   /*   一趟排序   */\r\n			if (LT(L->elem[k + 1].key, L->elem[k].key))\r\n			{\r\n				flag = FALSE;\r\n				L->elem[0] = L->elem[k];\r\n				L->elem[k] = L->elem[k + 1];\r\n				L->elem[k + 1] = L->elem[0];\r\n			}\r\n		if (flag == TRUE) {\r\n			break;\r\n		}\r\n	}\r\n}\r\n//数据遍历\r\nshow(ssTable st) {\r\n	int i;\r\n	printf(\"数据\\n\");\r\n	for (i = 1; i <= st.length; i++)\r\n	{\r\n		printf(\"%d\\t\", st.elem[i].key);\r\n		if (i % 10 == 0)\r\n		{\r\n			printf(\"\\n\");\r\n		}\r\n	}\r\n}\r\n//BST\r\nBSTNode* InsertBST(keyType key, BSTNode* BST)\r\n{\r\n	if (!BST)//若原树为空，生成并返回一个只有一个结点的二叉树一个\r\n	{\r\n		BST = (BSTNode*)malloc(sizeof(BSTNode));//有问题！！！\r\n		BST->key = key;\r\n		BST->Lchild = NULL;\r\n		BST->Rchild = NULL;\r\n		count++;\r\n	}\r\n	else if (key < BST->key)\r\n	{\r\n		BST->Lchild = InsertBST(key, BST->Lchild);\r\n	}\r\n	else if (key > BST->key)\r\n	{\r\n		BST->Rchild = InsertBST(key, BST->Rchild);\r\n	}\r\n	return BST;\r\n}\r\n//查找\r\nBSTNode* BSTSerach(BSTNode* T, keyType key)\r\n{\r\n	BSTNode* p = T;\r\n	compareCount = 0;\r\n	while (p != NULL && !EQ(p->key, key))\r\n	{\r\n		if (LT(key, p->key)) {\r\n			compareCount++;\r\n			p = p->Lchild;\r\n		}\r\n		else {\r\n			compareCount++;\r\n			p = p->Rchild;\r\n		}\r\n	}\r\n	if (p == NULL) {\r\n		return(NULL);\r\n	}\r\n	else if(EQ(p->key, key)) \r\n	{\r\n		printf(\"BST查找比较次数：%d \", compareCount);\r\n		return(p);\r\n	}\r\n\r\n}\r\nvoid PreorderTraverse1(BSTNode* T) {\r\n	if (T != NULL) {\r\n		PreorderTraverse1(T->Lchild);\r\n		printf(\"%d\\t\", T->key);\r\n		PreorderTraverse1(T->Rchild);\r\n	}\r\n}\r\n//刷新数据\r\nssTable refresh(ssTable ST) {\r\n	int data;\r\n	len = 1;\r\n	while (len <= 100)\r\n	{\r\n		data = rand() % 1000;\r\n		ST.elem[len].key = data;\r\n		ST.length = len++;\r\n	}\r\n	return ST;\r\n}\r\nvoid main() {\r\n\r\n	ssTable ST, st;\r\n	int data;\r\n	while (len <= 100)\r\n	{\r\n		data = rand() % 1000;\r\n		ST.elem[len].key = data;\r\n		ST.length = len++;\r\n	}\r\n	st = ST;\r\n	BubbleSort(&ST);\r\n	show(ST);\r\n	srand((int)time(NULL));\r\n	//分块查找\r\n	ssTable s;\r\n	s.elem[1].key = 22;\r\n	s.elem[2].key = 12;\r\n	s.elem[3].key = 13;\r\n	s.elem[4].key = 8;\r\n	s.elem[5].key = 9;\r\n	s.elem[6].key = 20;\r\n	s.elem[7].key = 33;\r\n	s.elem[8].key = 42;\r\n	s.elem[9].key = 44;\r\n	s.elem[10].key = 38;\r\n	s.elem[11].key = 24;\r\n	s.elem[12].key = 48;\r\n	s.elem[13].key = 60;\r\n	s.elem[14].key = 58;\r\n	s.elem[15].key = 74;\r\n	s.elem[16].key = 57;\r\n	s.elem[17].key = 86;\r\n	s.elem[18].key = 53;\r\n	s.length = 18;\r\n	Index ind[4];\r\n	ind[1].maxkey = 22;\r\n	ind[2].maxkey = 48;\r\n	ind[3].maxkey = 86;\r\n	ind[1].startpos = 1;\r\n	ind[2].startpos = 7;\r\n	ind[3].startpos = 13;\r\n	//tree\r\n	BSTNode B, * P;\r\n	B.key = ST.elem[1].key;\r\n	B.Lchild = B.Rchild = NULL;\r\n	srand((int)time(NULL)); //设定随机数种子\r\n	for (i = 1; i < ST.length; i++)\r\n	{\r\n		InsertBST(ST.elem[i].key, &B);\r\n	}\r\n\r\n\r\n\r\n\r\n	//文本页面\r\n	printf(\"\\n\\n\");\r\n	printf(\"\\t┏━━━━━━━━━━━━━━━━━━━━━━━━━┓\\n\");\r\n	printf(\"\\t┃          查找                                  \\n\");\r\n	printf(\"\\t┃  1、全部查找（数据有序）    \\n\");\r\n	printf(\"\\t┃  2、顺序查找                              \\n\");\r\n	printf(\"\\t┃  3、折半查找                              \\n\");\r\n	printf(\"\\t┃  4、插值查找                              \\n\");\r\n	printf(\"\\t┃  5、斐波那契查找                              \\n\");\r\n	printf(\"\\t┃  6、原始数据（未经排序）           \\n\");\r\n	printf(\"\\t┃  7、分块查找           \\n\");\r\n	printf(\"\\t┃  8、BST查找           \\n\");\r\n	printf(\"\\t┃  9、刷新数据           \\n\");\r\n	printf(\"\\t┃  10、退出                                   \\n\");\r\n	printf(\"\\t┗━━━━━━━━━━━━━━━━━━━━━━━━━┛\\n\\n\");\r\n	int a, i, flag = 1;\r\n	while (flag == 1)\r\n	{\r\n		printf(\"\\n\");\r\n		scanf_s(\"%d\", &a);\r\n		switch (a)\r\n		{\r\n		case	1:\r\n			printf(\"请输入查找的值：\");\r\n			scanf_s(\"%d\", &data);\r\n			show(ST);\r\n			i = seqSearch(ST, data);\r\n			printf(\"key为：%d 顺序查找结果：%d\\t\", data, i);\r\n			printf(\"\\n\\n\");\r\n			i = BinSearch(ST, data);\r\n			printf(\"key为：%d 折半查找结果：%d\\t\", data, i);\r\n			printf(\"\\n\\n\");\r\n			i = InsertionSearch(ST, data);\r\n			printf(\"key为：%d 插值查找结果：%d\\t\", data, i);\r\n			printf(\"\\n\\n\");\r\n			i = FibSearch(ST, data, ST.length);\r\n			printf(\"key为：%d 斐波那契查找结果：%d\\t\", data, i);\r\n			printf(\"\\n\\n\");\r\n			P = BSTSerach(&B, data);\r\n			printf(\"%d所在节点的地址为：%p\", data, P);\r\n			break;\r\n		case 2:\r\n			printf(\"请输入查找的值：\");\r\n			scanf_s(\"%d\", &data);\r\n			show(ST);\r\n			i = seqSearch(ST, data);\r\n			printf(\"key为：%d 顺序查找结果：%d\\t\", data, i);\r\n			break;\r\n		case 3:\r\n			printf(\"请输入查找的值：\");\r\n			scanf_s(\"%d\", &data);\r\n			show(ST);\r\n			i = BinSearch(ST, data);\r\n			printf(\"key为：%d 折半查找结果：%d\\t\", data, i);\r\n			printf(\"\\n\");\r\n			break;\r\n		case 4:\r\n			printf(\"请输入查找的值：\");\r\n			scanf_s(\"%d\", &data);\r\n			show(ST);\r\n			i = InsertionSearch(ST, data);\r\n			printf(\"key为：%d 插值查找结果：%d\\t\", data, i);\r\n			printf(\"\\n\");\r\n			break;\r\n		case 5:\r\n			printf(\"请输入查找的值：\");\r\n			scanf_s(\"%d\", &data);\r\n			show(ST);\r\n			i = FibSearch(ST, data, ST.length);\r\n			printf(\"key为：%d 斐波那契查找结果：%d\\t\", data, i);\r\n			printf(\"\\n\");\r\n			break;\r\n		case 6:\r\n			show(st);\r\n			break;\r\n		case 7:\r\n			show(s);\r\n			printf(\"\\n\");\r\n			i = Block_search(s, ind, 24, 18, 3);\r\n			printf(\"分块查找：24的位置在：%d\", i);\r\n			break;\r\n		case 8:\r\n		{\r\n			//while (count < 100)\r\n			//{\r\n			//	key = rand() % 100; //产生 0 - 99 的随机数。\r\n			//	InsertBST(key, &B);\r\n			//}\r\n			printf(\"中序遍历：\\n\");\r\n			PreorderTraverse1(&B);\r\n			printf(\"\\n请输入查找的值：\");\r\n			scanf_s(\"%d\", &data);\r\n			P = BSTSerach(&B, data);\r\n			printf(\"%d所在节点的地址为：%p\", data, P);\r\n			break;\r\n		}\r\n		case 9:\r\n			ST = refresh(ST);\r\n			st = ST;\r\n			BubbleSort(&ST);\r\n			B.key = ST.elem[1].key;\r\n			B.Lchild = B.Rchild = NULL;\r\n			srand((int)time(NULL)); //设定随机数种子\r\n			for (i = 1; i < ST.length; i++)\r\n			{\r\n				InsertBST(ST.elem[i].key, &B);\r\n			}\r\n			show(ST);\r\n			break;\r\n		case	10:\r\n			//退出\r\n			flag = -1;\r\n			break;\r\n		}\r\n	}\r\n\r\n}\r\n```', '2021-07-23 21:34:13', '包括：顺序查找、折半查找、插值查找、斐波那契查找、分块查找、BST查找', 'https://pic2.zhimg.com/80/v2-cc1e57e54d4e657042e6d5c310cbf41f_1440w.jpg', '原创', 1, 1, '常见的查找算法', '2022-03-23 22:02:49', 71, 3, 1);
INSERT INTO `t_blog` VALUES (7, 1, '```c\r\n#include <stdio.h>\r\n#include <time.h>\r\n#define  maxSize  101\r\n# define  maxStack  101\r\n#define  EQ(a, b)   ((a)==(b))\r\n#define  LT(a, b)   ((a)<(b))\r\n#define  LQ(a, b)   ((a)<=(b))\r\n#define TRUE 1\r\n#define FALSE 0\r\nint compareCount[6] = {0};\r\nint moveCount[6] = {0};\r\ntypedef  int  KeyType;\r\ntypedef  struct  RecType\r\n{\r\n	KeyType  key;          /* 关键字码  */\r\n}RecType;\r\ntypedef  struct Sqlist\r\n{\r\n	RecType  R[maxSize];\r\n	int length;\r\n}Sqlist;\r\n//冒泡排序\r\nvoid bubbleSort(Sqlist L,int sFlag)\r\n{\r\n	int j, k, flag;\r\n	compareCount[0]=0;\r\n	moveCount[0]=0;\r\n	for (j = 1; j < L.length; j++)       /*   共有n-1趟排序   */\r\n	{\r\n		flag = TRUE;\r\n		for (k = 1; k <= L.length - j; k++)   /*   一趟排序   */\r\n			if (LT(L.R[k + 1].key, L.R[k].key))\r\n			{\r\n				compareCount[0]++;\r\n				moveCount[0]+=3;\r\n				flag = FALSE;\r\n				L.R[0] = L.R[k];\r\n				L.R[k] = L.R[k + 1];\r\n				L.R[k + 1] = L.R[0];\r\n			}\r\n			else\r\n			{\r\n				compareCount[0]++;\r\n			}\r\n		if (flag == TRUE)\r\n			break;\r\n	}\r\n	if (sFlag==1)\r\n	{\r\n		show(L);\r\n		printf(\"冒泡排序比较次数为：%d 移动次数为：%d \", compareCount[0], moveCount[0]);\r\n	}\r\n	\r\n}\r\n//插入排序\r\nvoid straightInsertSort(Sqlist L, int sFlag)\r\n{\r\n	int i, j;\r\n	compareCount[1] = 0;\r\n	moveCount[1] = 0;\r\n	for (i = 2; i <= L.length; i++)\r\n	{\r\n		L.R[0] = L.R[i];\r\n		j = i - 1;     /*   设置哨兵   */\r\n		while (LT(L.R[0].key, L.R[j].key))\r\n		{\r\n			compareCount[1]++;\r\n			L.R[j + 1] = L.R[j];\r\n			j--;\r\n		}          /*   查找插入位置   */\r\n		compareCount[1]++;\r\n		moveCount[1]+=3;\r\n		L.R[j + 1] = L.R[0];      /*   插入到相应位置   */\r\n	}\r\n	if (sFlag == 1)\r\n	{\r\n		show(L);\r\n		printf(\"插入排序比较次数为：%d 移动次数为：%d \", compareCount[1], moveCount[1]);\r\n	}\r\n\r\n}\r\n//简单选择排序\r\nvoid simpleSelectionSort(Sqlist L, int sFlag)\r\n{\r\n	int m, n, k;\r\n	compareCount[2] = 0;\r\n	moveCount[2] = 0;\r\n	for (m = 1; m < L.length; m++)\r\n	{\r\n		k = m;\r\n		for (n = m + 1; n <= L.length; n++) {\r\n			if (LT(L.R[n].key, L.R[k].key)) {\r\n				k = n;\r\n				compareCount[2]++;\r\n			}\r\n			compareCount[2]++;\r\n		}\r\n		if (k != m)      /*   记录交换   */\r\n		{\r\n			moveCount[2]+=3;\r\n			L.R[0] = L.R[m];\r\n			L.R[m] = L.R[k];\r\n			L.R[k] = L.R[0];\r\n		}\r\n	}\r\n	if (sFlag == 1)\r\n	{\r\n		show(L);\r\n		printf(\"简单选择排序比较次数为：%d 移动次数为：%d \", compareCount[2], moveCount[2]);\r\n	}\r\n	\r\n}\r\n//快速排序\r\nint  quickOnePass(Sqlist* L, int low, int high)\r\n{\r\n	int i = low, j = high;\r\n	L->R[0] = L->R[i];       /*   R[0]作为临时单元和哨兵  */\r\n	do\r\n	{\r\n		while (LQ(L->R[0].key, L->R[j].key) && (j > i)) {\r\n			compareCount[3]++;\r\n			j--;\r\n		}\r\n		if (j > i) {\r\n			moveCount[3]+=3;\r\n			L->R[i] = L->R[j];\r\n			i++;\r\n		}\r\n		while (LQ(L->R[i].key, L->R[0].key) && (j > i)) {\r\n			compareCount[3]++;\r\n			i++;\r\n		}\r\n		if (j > i) {\r\n			moveCount[3]+=3;\r\n			L->R[j] = L->R[i];\r\n			j--;\r\n		}\r\n	} while (i != j);    /*   i=j时退出扫描  */\r\n	L->R[i] = L->R[0];\r\n	return(i);\r\n}\r\nvoid  quickSort(Sqlist* L, int low, int high)\r\n{\r\n	int k;\r\n	if (low < high)\r\n	{\r\n		k = quickOnePass(L, low, high);\r\n		quickSort(L, low, k - 1);\r\n		quickSort(L, k + 1, high);\r\n	}     /*   序列分为两部分后分别对每个子序列排序   */\r\n}\r\n//希尔排序\r\nvoid shellSort(Sqlist s, int n, int sFlag)    /* 自定义函数 shsort()*/\r\n{\r\n	int i, j, d;\r\n	compareCount[4] = 0;\r\n	moveCount[4] = 0;\r\n	d = n / 2;    /*确定固定增虽值*/\r\n	while (d >= 1)\r\n	{\r\n		for (i = d + 1; i <= n; i++)    /*数组下标从d+1开始进行直接插入排序*/\r\n		{\r\n			s.R[0].key = s.R[i].key;    /*设置监视哨*/\r\n			j = i - d;    /*确定要进行比较的元素的最右边位置*/\r\n			while ((j > 0) && (s.R[0].key < s.R[j].key))\r\n			{\r\n				moveCount[4]+=3;\r\n				compareCount[4]++;\r\n				s.R[j + d].key = s.R[j].key;    /*数据右移*/\r\n				j = j - d;    /*向左移d个位置V*/\r\n			}\r\n			compareCount[4]++;\r\n			s.R[j + d].key = s.R[0].key;    /*在确定的位罝插入s[i]*/\r\n		}\r\n		d = d / 2;    /*增里变为原来的一半*/\r\n	}\r\n	if (sFlag == 1)\r\n	{\r\n		show(s);\r\n		printf(\"希尔排序比较次数为：%d 移动次数为：%d \", compareCount[4], moveCount[4]);\r\n	}\r\n	\r\n}\r\n//堆排序\r\n//将以 r[s]为根结点的子树构成堆，堆中每个根结点的值都比其孩子结点的值大\r\nvoid HeapAdjust(Sqlist* H, int s, int m) {\r\n	RecType rc = H->R[s];//先对操作位置上的结点数据进行保存，放置后序移动元素丢失。\r\n	//对于第 s 个结点，筛选一直到叶子结点结束\r\n	for (int j = 2 * s; j <= m; j *= 2) {\r\n		//找到值最大的孩子结点\r\n		if (j + 1 < m && (H->R[j].key < H->R[j + 1].key)) {\r\n			compareCount[5]++;\r\n			j++;\r\n		}\r\n		//如果当前结点比最大的孩子结点的值还大，则不需要对此结点进行筛选，直接略过\r\n		if (!(rc.key < H->R[j].key)) {\r\n			break;\r\n		}\r\n		//如果当前结点的值比孩子结点中最大的值小，则将最大的值移至该结点，由于 rc 记录着该结点的值，所以该结点的值不会丢失\r\n		H->R[s] = H->R[j];\r\n		s = j;//s相当于指针的作用，指向其孩子结点，继续进行筛选\r\n	}\r\n	H->R[s] = rc;//最终需将rc的值添加到正确的位置\r\n}\r\n//交换两个记录的位置\r\nvoid swap(RecType* a, RecType* b) {\r\n	moveCount[5]+=3;\r\n	int key = a->key;\r\n	a->key = b->key;\r\n	b->key = key;\r\n}\r\nvoid HeapSort(Sqlist H, int sFlag) {\r\n	//构建堆的过程\r\n	compareCount[5] = 0;\r\n	moveCount[5] = 0;\r\n	for (int i = H.length / 2; i > 0; i--) {\r\n		//对于有孩子结点的根结点进行筛选\r\n		HeapAdjust(&H, i, H.length);\r\n	}\r\n	//通过不断地筛选出最大值，同时不断地进行筛选剩余元素\r\n	for (int i = H.length; i > 1; i--) {\r\n		//交换过程，即为将选出的最大值进行保存大表的最后，同时用最后位置上的元素进行替换，为下一次筛选做准备\r\n		swap(&(H.R[1]), &(H.R[i]));\r\n		//进行筛选次最大值的工作\r\n		HeapAdjust(&H, 1, i - 1);\r\n	}\r\n	if (sFlag == 1)\r\n	{\r\n		show(H);\r\n		printf(\"堆排序比较次数为：%d 移动次数为：%d \", compareCount[5], moveCount[5]);\r\n	}\r\n	\r\n}\r\n\r\n//打印数据\r\n show(Sqlist sq) {\r\n	int i;\r\n	for (i = 1; i <= sq.length; i++)\r\n	{\r\n		printf(\"%d\\t\", sq.R[i].key);\r\n		if (i % 10 == 0)\r\n		{\r\n			printf(\"\\n\");\r\n		}\r\n	}\r\n}\r\n\r\nvoid main() {\r\n	int random, i;\r\n	Sqlist Sq, Sq1, Sq2;\r\n	Sq.length = 0;\r\n	srand((int)time(NULL));\r\n	for (i = 1; i <= 100; i++)\r\n	{\r\n		random = rand() % 1000;//产生 0 - 99 的随机数。\r\n		Sq.R[i].key = random;\r\n		++Sq.length;\r\n	}\r\n	Sq1 = Sq;\r\n	Sq2 = Sq;\r\n	printf(\"初始数据：\\n\");\r\n	show(Sq);\r\n	//文本页面\r\n	printf(\"\\n\\n\");\r\n	printf(\"\\t┏━━━━━━━━━━━━━━━━━━━━━━━━━┓\\n\");\r\n	printf(\"\\t┃          排序                                    \\n\");\r\n	printf(\"\\t┃  0、各个排序比较次数和移动次数展示    \\n\");\r\n	printf(\"\\t┃  1、生成正序数据    \\n\");\r\n	printf(\"\\t┃  2、生成倒序数据                              \\n\");\r\n	printf(\"\\t┃  3、刷新数据                              \\n\");\r\n	printf(\"\\t┃  4、数据展示                              \\n\");\r\n	printf(\"\\t┃  5、起泡排序                              \\n\");\r\n	printf(\"\\t┃  6、直接插入排序           \\n\");\r\n	printf(\"\\t┃  7、简单选择排序           \\n\");\r\n	printf(\"\\t┃  8、快速排序           \\n\");\r\n	printf(\"\\t┃  9、希尔排序           \\n\");\r\n	printf(\"\\t┃  10、堆排序           \\n\");\r\n	printf(\"\\t┃  11、退出                                   \\n\");\r\n	printf(\"\\t┗━━━━━━━━━━━━━━━━━━━━━━━━━┛\\n\\n\");\r\n	int a, flag = 1;\r\n	while (flag == 1)\r\n	{\r\n		printf(\"\\n\");\r\n		scanf_s(\"%d\", &a);\r\n		switch (a)\r\n		{\r\n		case 0:\r\n			bubbleSort(Sq, 0);\r\n			straightInsertSort(Sq, 0);\r\n			simpleSelectionSort(Sq, 0);\r\n			quickSort(&Sq1, 1, 100);\r\n			shellSort(Sq, 100, 0);\r\n			HeapSort(Sq2, 0);\r\n			printf(\"\\t冒泡排序\\t比较次数为：%d 移动次数为：%d\\n \", compareCount[0], moveCount[0]);\r\n			printf(\"\\t插入排序\\t比较次数为：%d 移动次数为：%d \\n\", compareCount[1], moveCount[1]);\r\n			printf(\"\\t选择排序\\t比较次数为：%d 移动次数为：%d\\n \", compareCount[2], moveCount[2]);\r\n			printf(\"\\t快速排序\\t比较次数为：%d 移动次数为：%d \\n\", compareCount[3], moveCount[3]);\r\n			printf(\"\\t希尔排序\\t比较次数为：%d 移动次数为：%d \\n\", compareCount[4], moveCount[4]);\r\n			printf(\"\\t堆排序    \\t比较次数为：%d 移动次数为：%d \\n\", compareCount[5], moveCount[5]);\r\n			compareCount[3] = moveCount[3] = 0;\r\n			break;\r\n		case 1:\r\n			Sq.length = 0;\r\n			for (i = 1; i <= 100; i++)\r\n			{\r\n				random = i + 2;\r\n				Sq.R[i].key = random;\r\n				++Sq.length;\r\n			}\r\n			show(Sq);\r\n			Sq1 = Sq;\r\n			Sq2 = Sq;\r\n			break;\r\n		case 2: {\r\n			int k;\r\n			Sq.length = 0;\r\n			for (k = 1, i = 100; i >= 1; i--, k++)\r\n			{\r\n				random = i + 2;\r\n				Sq.R[k].key = random;\r\n				++Sq.length;\r\n			}\r\n			show(Sq);\r\n			Sq1 = Sq;\r\n			Sq2 = Sq;\r\n			break;\r\n		}\r\n		case 3:\r\n			Sq.length = 0;\r\n			for (i = 1; i <= 100; i++)\r\n			{\r\n				random = rand() % 1000;//产生 0 - 99 的随机数。\r\n				Sq.R[i].key = random;\r\n				++Sq.length;\r\n			}\r\n			show(Sq);\r\n			Sq1 = Sq;\r\n			Sq2 = Sq;\r\n			break;\r\n		case 4:\r\n			show(Sq);\r\n			break;\r\n		case 5:\r\n			bubbleSort(Sq,1);\r\n			break;\r\n		case 6:\r\n			straightInsertSort(Sq,1);\r\n			break;\r\n		case 7:\r\n			simpleSelectionSort(Sq,1);\r\n			break;\r\n		case 8:\r\n			quickSort(&Sq1, 1, 100);\r\n			show(Sq1);\r\n			printf(\"快速排序比较次数为：%d 移动次数为：%d \", compareCount[3], moveCount[3]);\r\n			compareCount[3] = moveCount[3] = 0;\r\n			break;\r\n		case 9:\r\n			shellSort(Sq, 100,1);\r\n			break;\r\n		case 10:\r\n			HeapSort(Sq2,1);\r\n			break;\r\n		case	11:\r\n			flag = -1;\r\n			break;\r\n		}\r\n	}\r\n\r\n}\r\n```', '2021-07-23 21:36:29', '冒泡排序、插入排序、选择排序、快速排序、希尔排序、堆排序', 'https://pic1.zhimg.com/80/v2-84d384e689f0e43f36671c662875c454_1440w.jpg', '原创', 1, 1, '经典排序算法', '2022-03-23 22:02:36', 73, 3, 1);
INSERT INTO `t_blog` VALUES (8, 1, '```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\ntypedef int ElemType;\r\n\r\ntypedef struct Lnode {\r\n	ElemType data;\r\n	struct Lnode* next;\r\n}LNode;\r\n//前插法创建单链表\r\nvoid CreateList_H(LNode* L, int n) {\r\n	printf(\"前插法！！\\n\");\r\n	int i,e;\r\n	L->next = NULL;\r\n	LNode* p;\r\n	for ( i = 0; i < n; i++)\r\n	{\r\n		printf(\"输的第%d个元素: \\n\", i + 1);\r\n		scanf_s(\"%d\", &e);\r\n		p = (struct Lnode*)malloc(sizeof(struct Lnode));\r\n		p->next = L->next;\r\n		p->data = e;\r\n		L->next = p;\r\n	}\r\n}\r\n//尾插法创建单链表\r\nvoid CreateList_E(LNode* L, int n) {\r\n	printf(\"尾插法！！！\\n\");\r\n	int i, e;\r\n	LNode* l,*r;\r\n	L->next = NULL;\r\n	r = L;\r\n	for (i = 0; i < n; i++) {\r\n		printf(\"输的第%d个元素: \\n\", i + 1);\r\n		scanf_s(\"%d\", &e);\r\n		l= (struct Lnode*)malloc(sizeof(struct Lnode));\r\n		l->data = e;\r\n		l->next = NULL;\r\n		r->next = l;\r\n		r = l;\r\n	}\r\n}\r\n//单链表按序号查找\r\nvoid ListSearch_N(LNode* L) {\r\n	int i,n;\r\n	printf(\"\\n取单链表的第N个元素：\");\r\n	scanf_s(\"%d\", &n);\r\n	for (i = 1; i <= n; i++) {\r\n		L = L->next;\r\n		if (i == n) {\r\n			printf(\"%d\\n\", L->data);\r\n			break;\r\n		}\r\n		if (L->next == NULL) {\r\n			printf(\"NOt found\\n \");\r\n			break;\r\n		}\r\n	}\r\n}\r\n// 单链表按值查找\r\nLNode* ListSrearch_E(LNode* L) {\r\n	int  e;\r\n	printf(\"\\n输入要查找的值：\");\r\n	scanf_s(\"%d\", &e);\r\n	while (L->next != NULL)\r\n	{\r\n		if (L->data == e) {\r\n			return L; \r\n		}\r\n	}\r\n	return NULL;\r\n	printf(\"所查找的结点不存在！！\\n\");\r\n}\r\n// 单链表的插入\r\nvoid ListInsetrt(LNode *L , int n,ElemType e) {\r\n	LNode* p1, * p2;\r\n	int j = 1;\r\n	p2 = L;\r\n	while (p2->next !=NULL && j<n)\r\n	{\r\n		p2 = p2->next;\r\n		j++;\r\n	}\r\n	if (j != n ) {\r\n		printf(\"n太大或者n为0！！！\");\r\n	}\r\n	else {\r\n		p1 = (LNode*)malloc(sizeof(LNode));\r\n		p1->data=e;\r\n		p1->next = p2->next;\r\n		p2->next = p1;\r\n	}\r\n}\r\n// 单链表按值删除\r\nvoid Delete_E(LNode *L) {\r\n	ElemType e;\r\n	printf(\"请输入要删除的值: \");\r\n	scanf_s(\"%d\", &e);\r\n	LNode* p,*q;\r\n	q = L->next;\r\n	p = L;\r\n	while (q->next !=NULL  &&   q->data !=e)\r\n	{\r\n		p = q;\r\n		q = q->next;\r\n	}\r\n	if (q->data == e) {\r\n		p->next = q->next;\r\n		free(q);\r\n	}\r\n	else\r\n	{\r\n		printf(\"所要删除的值不存在！！\\n\");\r\n	}\r\n}\r\n// 单链表按位置删除\r\nvoid Delete_N( LNode *L)  {\r\n	int n,i=1;\r\n	printf(\"请输入要删除的位置: \");\r\n	scanf_s(\"%d\", &n );\r\n	LNode* p, * q;\r\n	p= L;\r\n	q = L->next;\r\n	while ( p->next!=NULL &&  i< n)\r\n	{\r\n		p = q;\r\n		q = q->next;\r\n		i++;\r\n	}\r\n	if (i != n)     \r\n		printf(\"i太大或i为0!!\\n \");\r\n	else\r\n	{\r\n		p->next = q->next;   \r\n		free(q);\r\n	}\r\n}\r\n//遍历链表\r\nvoid show(LNode* L) {\r\n	LNode *p;\r\n	p = (struct Lnode*)malloc(sizeof(struct Lnode));\r\n	p->next = L->next;\r\n	while(1) {\r\n		if (p->next == NULL) {\r\n			break;\r\n		}\r\n		else\r\n		{\r\n			p = p->next;\r\n			printf(\"%d \\t\", p->data);\r\n		}\r\n	}\r\n	printf(\"\\n\");\r\n}\r\n//两个链表的合并\r\nLNode* MergeLnode(LNode* La, LNode* Lb,LNode*Lc) {\r\n	LNode * pa, * pb, * pc, * ptr;\r\n	 Lc= La; pc = La; pa = La->next; pb = Lb->next;\r\n	while (pa!=NULL && pb!=NULL)\r\n	{\r\n		if (pa->data < pb->data) {\r\n			pc->next = pa; pc = pa; pa = pa->next;\r\n		}\r\n		if (pa->data > pb->data) {\r\n			pc->next = pb; pc = pb; pb = pb->next;\r\n		}\r\n		if (pa->data == pb->data)\r\n		{\r\n			pc->next = pa; pc = pa; pa = pa->next; \r\n			ptr = pb; pb = pb->next; free(ptr);\r\n		}\r\n	}\r\n	if (pa!=NULL)\r\n	{\r\n		pc->next = pa;\r\n	}\r\n	else\r\n	{\r\n		pc->next = pb;\r\n	}\r\n	free(Lb);\r\n	return Lc;\r\n}\r\n//删除链表中相同值\r\nvoid DeleteNormal(LNode *L) {\r\n	LNode* ptr,*q;\r\n	ElemType e;\r\n	ptr = L->next;\r\n	while (ptr!=NULL)\r\n	{\r\n		e = ptr->data;\r\n		while (ptr->next != NULL)\r\n		{\r\n			\r\n			if (ptr->data == e) {\r\n				q = ptr->next;\r\n				ptr->next = q->next;\r\n				free(q);\r\n			}\r\n		ptr++;\r\n		}\r\n		ptr++;\r\n	}\r\n}\r\nvoid main() {\r\n	int n;\r\n	LNode  L, L2, L3;\r\n	printf(\"请输入创建链表包含的元素个数N: \");\r\n	scanf_s(\"%d\", &n);\r\n	CreateList_H(&L, n);\r\n	CreateList_E(&L2, n);\r\n	show(&L);\r\n	show(&L2);\r\n	ListSearch_N(&L);\r\n	ListInsetrt(&L, 3, 4);\r\n	show(&L);\r\n	Delete_N(&L);\r\n	show(&L);\r\n	Delete_E(&L);\r\n	show(&L);\r\n	DeleteNormal(&L2);\r\n	show(&L2);\r\n\r\n}\r\n```', '2021-07-23 21:39:07', '链表基本操作\r\n', 'https://pica.zhimg.com/80/v2-0c7f9ac3e8cd2328e18d5c65fcfb0a17_1440w.jpg', '原创', 1, 0, '链表', '2022-03-23 22:02:23', 55, 3, 1);
INSERT INTO `t_blog` VALUES (9, 1, '```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#define ERROR -1;\r\n#define OK 1;\r\ntypedef int Status;\r\ntypedef int ElemType;\r\ntypedef struct {\r\n	ElemType data;\r\n	struct StackLnode* next;\r\n}StackLnode;\r\n//初始化\r\nStatus InitStackLnode(StackLnode* S) {\r\n	S->next = NULL;\r\n	return OK;\r\n}\r\n//入栈\r\nStatus PushStackLnode(StackLnode* S, ElemType e) {\r\n	StackLnode* p;\r\n	p = (StackLnode*)malloc(sizeof(StackLnode));\r\n	if (p == NULL) {\r\n		return ERROR;\r\n	}\r\n	p->data = e;\r\n	p->next = S->next;\r\n	S->next = p;\r\n}\r\n//出栈\r\nStatus PopStackLnode(StackLnode* S , ElemType *e) {\r\n	if (S->next ==NULL)\r\n	{\r\n		return ERROR;\r\n	}\r\n	StackLnode* p;\r\n	p = S->next;\r\n	*e = p->data;\r\n	S->next = p->next;\r\n	free(p);\r\n	return OK;\r\n}\r\n//遍历\r\nshow(StackLnode* S) {\r\n	StackLnode* p;\r\n	p = (StackLnode*)malloc(sizeof(StackLnode));\r\n	p = S->next;\r\n	while (p !=NULL)\r\n	{\r\n		printf(\"%d \", p->data);\r\n		p=p->next;\r\n	}\r\n	printf(\"\\n\");\r\n}\r\nint main() {\r\n	StackLnode S;\r\n	ElemType e;\r\n	InitStackLnode(&S);\r\n	PushStackLnode(&S, 1);\r\n	PushStackLnode(&S, 1);\r\n	PushStackLnode(&S, 3);\r\n	PushStackLnode(&S, 4);\r\n	show(&S);\r\n	PopStackLnode(&S,&e);\r\n	printf(\"%d\\n\", e);\r\n	show(&S);\r\n	return 0;\r\n}\r\n```', '2021-07-23 21:40:46', '入栈、出栈等', 'https://pica.zhimg.com/80/v2-6c341ca76eae290e2cf95d1c0f6b0d0f_1440w.jpg', '原创', 1, 0, '链栈', '2022-03-23 22:02:10', 88, 3, 1);
INSERT INTO `t_blog` VALUES (10, 1, '```c\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#define Error -1;\r\n#define Ok 1;\r\ntypedef int Status;\r\ntypedef int ElemType;\r\ntypedef struct {\r\n	ElemType data;\r\n	struct Qnode* next;\r\n}Qnode,*QueuePtr;\r\ntypedef struct {\r\n	QueuePtr front;\r\n	QueuePtr rear;\r\n}LinkQueue;\r\n//初始化队列\r\nStatus InitQueue(LinkQueue* Q) {\r\n	Q->front = Q->rear = (Qnode*)malloc(sizeof(Qnode));\r\n	Q->front->next = NULL;\r\n}\r\n//销毁队列\r\nStatus DestroyQueue(LinkQueue* Q) {\r\n	free(Q);\r\n}\r\n//清空队列\r\nStatus ClearQueue(LinkQueue* Q) {\r\n	Qnode* p,*q;\r\n	p = Q->front->next;\r\n	while (1)\r\n	{\r\n		q = p;\r\n		p = p->next;\r\n		free(q);\r\n		if (p == Q->rear)\r\n		{\r\n			break;\r\n		}\r\n	}\r\n	Q->rear = Q->front;\r\n}\r\n//判断是否为空队列\r\nStatus QueueEmpty(LinkQueue* Q) {\r\n	if (Q->front == Q->rear)\r\n	{\r\n		printf(\"空！\");\r\n	}\r\n}\r\n//返回元素数量\r\nStatus QueueLength(LinkQueue* Q) {\r\n	Qnode* p;\r\n	int i=1;\r\n	p = Q->front;\r\n	while (1)\r\n	{\r\n		if (Q->front == Q->rear)\r\n		{\r\n			printf(\"空队列！！\");\r\n		}\r\n		if (p->next == NULL) {\r\n			break;\r\n		}\r\n		p = p->next;\r\n		i++;\r\n\r\n	}\r\n	printf(\" 元素有：%d个 \\n\",i);\r\n	printf(\"\\n\");\r\n}\r\n//返回队头元素\r\nStatus GetHead(LinkQueue* Q) {\r\n	Qnode* p = Q->front;\r\n	if (Q->front!=Q->rear)\r\n	{\r\n		p = p->next;\r\n		return p->data;\r\n	}\r\n}\r\n//入队\r\nStatus EnQueue(LinkQueue* Q , ElemType e) {\r\n	Qnode* p;\r\n	p = (Qnode*)malloc(sizeof(Qnode));\r\n	p->data = e;\r\n	p->next = NULL;\r\n	Q->rear->next = p;\r\n	Q ->rear= p;\r\n}\r\n//出队\r\nStatus DeQueue(LinkQueue* Q,ElemType *e) {\r\n	if (Q->front == Q->rear)\r\n	{\r\n		return Error;\r\n	}\r\n	Qnode* p;\r\n	p = Q->front->next;\r\n	*e = p->data;\r\n	Q->front->next = p->next;\r\n	if (p==Q->rear)\r\n	{\r\n		Q->rear = Q->front;\r\n	}\r\n	free(p);\r\n	return Ok;\r\n}\r\n//遍历队列\r\nShow(LinkQueue* Q) {\r\n	Qnode* p;\r\n	printf(\"\\n遍历队列：\");\r\n	p = Q->front;\r\n	while (1)\r\n	{\r\n		if (Q->front == Q->rear)\r\n		{\r\n			printf(\"空队列！！\");\r\n			break;\r\n		}\r\n		if (p->next==NULL) {\r\n			break;\r\n		}\r\n        p = p->next;\r\n		printf(\" %d \", p->data);\r\n		\r\n	}\r\n	printf(\"\\n\");\r\n}\r\nvoid main() {\r\n	LinkQueue Q;\r\n	ElemType e;\r\n	InitQueue(&Q);\r\n	EnQueue(&Q, 1);\r\n	EnQueue(&Q, 2);\r\n	EnQueue(&Q, 3);\r\n	EnQueue(&Q, 4);\r\n	EnQueue(&Q, 5);\r\n	Show(&Q);\r\n	printf(\"\\n出队的元素：%d\\n\", DeQueue(&Q, &e));\r\n	Show(&Q);\r\n	printf(\"\\n队首的元素：%d\\n\", GetHead(&Q));\r\n	ClearQueue(&Q);\r\n	Show(&Q);\r\n}\r\n```', '2021-07-23 21:43:57', '要记得队列是啥呀！！！', 'https://pic2.zhimg.com/80/v2-b6a769a38503618fb6dae49f0bb43789_1440w.jpg', '原创', 1, 0, '链队列', '2022-03-23 22:01:52', 129, 3, 1);
INSERT INTO `t_blog` VALUES (14, 1, '我听说世界上每个人都有自己发展的时区，有人看似走在你前面，也有人看似走在你后面，每个人都有自己的步伐，每个人都有自己的时区。生命就是等待正确的时机行动。所以放轻松，你没有落后，你也没有领先，一切都很准时。在你自己的时区，一切都是最好的安排。', '2021-08-30 23:25:12', '我想你呀', 'https://pic4.zhimg.com/80/v2-667cb793bb32de6d39ba64db3242152d_1440w.jpg', '原创', 1, 1, '时区不同', '2022-03-23 22:01:25', 144, 2, 1);
INSERT INTO `t_blog` VALUES (15, 1, '如果电脑使用过向日葵控制软件，可能是因为开启了向日葵的黑屏驱动。那个黑屏驱动有bug，会导致电脑亮度无法调节。看到被这个问题困扰人比较多，之前自己的解决办法在评论里，不好找，自己发一篇回答。右键计算机，打开设备管理器，监视器一栏。卸载监视器（Generic Monitor (OrayDPMS)）要勾上删除驱动，删完了之后先禁用独显然后点击“查看”下面的“扫描检测硬件改动”，再看一下监视器那里，变成“通用即插即用监视器”就好了，记得把独显恢复。\r\n', '2021-09-18 12:06:59', '谢谢啦', 'https://pic3.zhimg.com/80/v2-b730c73ebd78bd5f22293aab0d343f4b_1440w.jpg', '原创', 0, 1, '向日葵引发的笔记本亮度无法调节', '2022-03-23 22:01:10', 69, 2, 1);
INSERT INTO `t_blog` VALUES (18, 0, '你要竭尽所能声张你认为的正义，待你羽翼丰满时逃离这个你熟悉又陌生的世界，越远越好，在彼方安家，再重新长大一次，重塑你的三观，那时你的温柔你的涵养应该会是现在的千百倍。', '2022-03-23 22:11:35', '向前看呀', 'https://s.cn.bing.net/th?id=OIP-C.h2ggFc79mKB0Cr5ggfhZGwHaEo&w=316&h=197&c=8&rs=1&qlt=90&o=6&dpr=1.5&pid=3.1&rm=2', '原创', 1, 0, '远方', '2022-03-23 22:11:35', 145, 2, 1);
INSERT INTO `t_blog` VALUES (20, 0, '其实有时候，有很多事，有很多话都藏在心里，自身的欲望也变得越来越低。我不清楚这是不是所谓的成长，如果是的话，我承认我确实被它影响到了，虽然早已经过了那个可以无忧无虑的年纪，但是我真的好想念啊，可惜都回不去了，我甚至都忘了那是什么感觉，只是依稀记得很快乐。压力越来越来越大，能力也撑不起自己的野心。很多朋友说我已经不错了，让我相信自己。虽然最嘴上回应着好，但我知道，我还是摆脱不了这种想法，真的很希望，我的结局快点来到，我真的太不喜欢模糊不确定的感觉。', '2022-03-26 06:47:53', '许愿未来', 'https://pic1.zhimg.com/80/v2-f959b1dd0a928a91cc1e6269273bf8f1_1440w.jpg', '原创', 1, 1, '迷茫', '2022-04-03 00:10:39', 159, 2, 1);
INSERT INTO `t_blog` VALUES (279665314, 0, '# 一、图像定义：\r\n\r\n二值图像指：每个像素点**均为黑色或者白色**的图像。\r\n\r\n灰度图像：每个像素的信息由一个量化的灰度级来描述的图像，没有彩色信息。\r\n\r\n彩色图像：每个像素的信息由RGB三原色构成的图像，其中RGB是由不同的灰度级来表示的。\r\n\r\n索引图像：索引图像包括一个数据矩阵X，一个颜色映像矩阵Map。 \r\n\r\n# 二、图像评价准则：\r\n\r\n均值：灰度的均值代表图像的亮度。\r\n\r\n方差：方差代表其对比度。\r\n\r\n相关系数：\r\n\r\n# 三、图像处理的一般方法及特点：\r\n\r\n图像滤波的目的有两个:一是抽出对象的特征作为图像识别的特征模式;另一个是为适应图像处理的要求，消除图像数字化时所混入的噪声。而对滤波处理的要求也有两条:一是不能损坏图像的轮廓及边缘等重要信息;二是使图像清晰视觉效果好。\r\n\r\n中值滤波：（非线性方法）图片中一个方块区域内，取像素的中指赋给其他像素点。\r\n\r\n均值滤波：（线性方法） 图片中一个方块区域内，中心点的像素为全部点像素值的平均值。均值滤波本身存在着固有的缺陷，即它不能很好地保护图像细节，在图像去噪的同时也破坏了图像的细节部分，从而使图像变得模糊，不能很好地去除噪声点。特别是椒盐噪声\r\n\r\n排序滤波：排序滤波器是一种非线性局部滤波器，它首先将窗口内的每个像素根据色彩的值进行排序，随后根据所给的序号得出最后的结果。\r\n\r\n# 四、直方图：imhist（img）\r\n\r\n概念：图像直方图是用以表示数字图像中亮度分布的直方图，标绘了图像中每个亮度值的像素数。\r\n\r\n直方图均衡化：是将原图像通过某种变换，得到一幅灰度直方图为均匀分布的新图像的方法。 直方图均衡化方法的基本思想是对在图像中像素个数多的灰度级进行展宽，而对像素个数少的灰度级进行缩减。 从而达到清晰图像的目的。\r\n\r\n直方图规定化：是通过一个灰度映像函数，将原灰度直方图改造成所希望的直方图。\r\n\r\n~~~\r\nf=rgb2gray(f);\r\ng1=imhist(g);\r\nmatch=histeq(f,g1);\r\n~~~\r\n\r\n# 五、图像处理的方法：\r\n\r\n图像恢复：从造成图像质量下降的客观原因出手，改善图像质量；试图恢复图像原来的面貌。图像恢复总是试图寻找引起图像质量下降的客观原因，有针对性地迕行 “恢复”处理。\r\n\r\n图像增强：从主观规觉角度，改善图像质量；不着重考虑引起图像质量下降的客观因素。\r\n\r\n图像压缩：减少表示数字图像时需要的数据量\r\n\r\n# 六、图像邻域：\r\n\r\n表示图像像素之间的连接关系，像素之间邻域类型有4邻域和8邻域。\r\n\r\n# 七、图像数字化方法：\r\n\r\n图像的数字化过程主要分采样、量化与编码三个步骤。\r\n\r\n- 采样的实质就是要用多少点来描述一幅图像。\r\n- 量化是指要使用多大范围的数值来表示图像采样之后的每一个点。\r\n- 压缩编码数字化后得到的图像数据量十分巨大，必须采用编码技术来压缩其信息量。\r\n\r\n# 八、傅里叶变化：ftf\r\n\r\n傅里叶变换是一种函数在空间域和频率的变换，从空间域到频率域的变换是傅里叶变换，而从频率域到空间域的转换叫做傅里叶的反变换。\r\n\r\n# 九、图像滤波器原理：\r\n\r\n线性滤波：对邻域中的像素的计算为线性运算时，如利用窗口函数进行平滑加权求和的运算，或者某种卷积运算，都可以称为线性滤波。常见的线性滤波有：方框滤波、均值滤波、高斯滤波、拉普拉斯滤波等等，通常线性滤波器之间只是模版的系数不同。\r\n\r\n非线性滤波：非线性滤波利用原始图像跟模版之间的一种逻辑关系得到结果，如最值滤波器，中值滤波器。比较常用的有中值滤波器和双边滤波器。\r\n\r\n# 十、空域滤波器和频率域滤波器对比：\r\n\r\n空域指图像本身，空域变换直接对图像中的像素进行操作。\r\n\r\n频域滤波是图像经傅里叶变换以后，边缘和其他尖锐变化（如噪音）在图像的灰度级中主要处于傅里叶变换的高频部分。\r\n\r\n图像在空域上具有很强的相关性，借助于正交变换可使在空域的复杂计算转换到频域后得到简化\r\n\r\n借助于频域特性的分析，将更有利于获得图像的各种特性和进行特殊处理\r\n\r\n# 十一、图像分割的定义和基本方法：\r\n\r\n图像分割就是指把图像分成各具特性的区域并提取出感兴趣目标的技术和过程。\r\n分割的目的：将图像划分为不同区域\r\n分割的依据：图像中各区域具有不同的特性，比如，灰度、颜色、纹理。目标可以对应单个区域，也可以对应多个区域。\r\n分割方法：\r\n\r\n基于边缘检测的图像分割\r\n基于阈值的图像分割\r\n基于跟踪的图像分割\r\n基于区域的图像分割\r\n\r\n# 十二、噪声：\r\n\r\n高斯噪声是一种源于电子电路噪声和由低照明度或高温带来的传感器噪声\r\n\r\n# 十三、图像压缩的基本概念：\r\n\r\n图像压缩是 数据压缩技术 在数字图像上的应用，它的目的是减少图像数据中的冗余信息从而用更加高效的格式存储和传输数据。\r\n\r\n# 十四、图像线性拉伸变化方法：\r\n\r\n图像拉伸是最基础的图像处理方法，主要用来改善图像显示的对比度，提取流程中往往首先要对图像进行拉伸的预处理。图像拉伸主要有三种方式：灰度拉伸、直方图均衡化和直方图规定化。\r\n\r\n线性拉伸\r\n全域线性拉伸\r\n大部分像素灰度分布在[a,b]时，可将[a,b]拉伸到[c,d]，常用方法。\r\n\r\n分段线性拉伸\r\n突出目标地物灰度区间，抑制不感兴趣的其他区间。\r\n\r\n分段窗口切片（Slicing）\r\n将某一区间灰度级与其他部分（即背景）区分开来。\r\n\r\n 非线性拉伸\r\n非线性，包括指数函数、对数函数、平方根、高斯函数等。\r\n\r\n指数变换\r\n高灰度区（亮的部分）扩大了灰度间隔，突出细节；低灰度区（暗的部分）缩小灰度间隔，弱化细节。\r\n\r\n对数变换\r\n低灰度区较大拉伸，高灰度区压缩，使图像灰度分布与人的视觉特性匹配。\r\n\r\n 多波段拉伸\r\n对各个波段分别进行线性拉伸或非线性拉伸，综合增强图像显示的地物信息。\r\n\r\n# 十五、卷积方法：\r\n\r\n图像卷积操作（convolution），或称为核操作（kernel），是进行图像处理的一种常用手段，\r\n\r\n图像卷积操作的目的是利用像素点和其邻域像素之前的空间关系，通过加权求和的操作，实现模糊（blurring），锐化（sharpening），边缘检测（edge detection）等功能。\r\n\r\n图像卷积的计算过程就是卷积核按步长对图像局部像素块进行加权求和的过程。', '2022-04-20 23:18:52', '嘻嘻嘻嘻', 'https://pic3.zhimg.com/80/v2-addac271c8474144769ffbf4a139f828_1440w.jpg', '原创', 1, 1, '数字图像处理', '2022-04-20 23:25:45', 106, 2, 1);
INSERT INTO `t_blog` VALUES (1795514317, 0, '### 一、技术栈\r\n\r\n原先博客系统是用了SpringBoot 1.5.7 ，SpringBoot JPA，现在改成了SpringBoot 2.5.1，orm框架用的是Mybatis-plus，为了提高访问速度加上了redis做缓存，主要用在主页的分页查询部分。对前端也进行一些小优化，修复了切换页面的时候会有白色闪屏问题。\r\n\r\n### 二、代码规范\r\n\r\n原先后端没有对接口返回数据进行封装，感觉数据有点凌乱，所以用了一份封装类，这对以后再进行前后端分离项目算是进行了铺垫。其实我也想做一个真正意义上前后端分离的项目，奈何我前端水平有限，这个计划还是放到以后吧，当然要是有会前端的好兄弟和我搭档一次开发一下，那也是极好的。\r\n\r\n~~~~java\r\n// 统一的接口返回结果\r\n@JsonInclude(JsonInclude.Include.NON_NULL)\r\npublic class ResponseResult<T> implements Serializable {\r\n    private Integer code;\r\n    private String msg;\r\n    private T data;\r\n\r\n    public ResponseResult() {\r\n        this.code = AppHttpCodeEnum.SUCCESS.getCode();\r\n        this.msg = AppHttpCodeEnum.SUCCESS.getMsg();\r\n    }\r\n\r\n    public ResponseResult(Integer code, T data) {\r\n        this.code = code;\r\n        this.data = data;\r\n    }\r\n\r\n    public ResponseResult(Integer code, String msg, T data) {\r\n        this.code = code;\r\n        this.msg = msg;\r\n        this.data = data;\r\n    }\r\n\r\n    public ResponseResult(Integer code, String msg) {\r\n        this.code = code;\r\n        this.msg = msg;\r\n    }\r\n\r\n    public static ResponseResult errorResult(int code, String msg) {\r\n        ResponseResult result = new ResponseResult();\r\n        return result.error(code, msg);\r\n    }\r\n    public static ResponseResult okResult() {\r\n        ResponseResult result = new ResponseResult();\r\n        return result;\r\n    }\r\n    public static ResponseResult okResult(int code, String msg) {\r\n        ResponseResult result = new ResponseResult();\r\n        return result.ok(code, null, msg);\r\n    }\r\n\r\n    public static ResponseResult okResult(Object data) {\r\n        ResponseResult result = setAppHttpCodeEnum(AppHttpCodeEnum.SUCCESS, AppHttpCodeEnum.SUCCESS.getMsg());\r\n        if(data!=null) {\r\n            result.setData(data);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public static ResponseResult errorResult(AppHttpCodeEnum enums){\r\n        return setAppHttpCodeEnum(enums,enums.getMsg());\r\n    }\r\n\r\n    public static ResponseResult errorResult(AppHttpCodeEnum enums, String msg){\r\n        return setAppHttpCodeEnum(enums,msg);\r\n    }\r\n\r\n    public static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums){\r\n        return okResult(enums.getCode(),enums.getMsg());\r\n    }\r\n\r\n    private static ResponseResult setAppHttpCodeEnum(AppHttpCodeEnum enums, String msg){\r\n        return okResult(enums.getCode(),msg);\r\n    }\r\n\r\n    public ResponseResult<?> error(Integer code, String msg) {\r\n        this.code = code;\r\n        this.msg = msg;\r\n        return this;\r\n    }\r\n\r\n    public ResponseResult<?> ok(Integer code, T data) {\r\n        this.code = code;\r\n        this.data = data;\r\n        return this;\r\n    }\r\n\r\n    public ResponseResult<?> ok(Integer code, T data, String msg) {\r\n        this.code = code;\r\n        this.data = data;\r\n        this.msg = msg;\r\n        return this;\r\n    }\r\n\r\n    public ResponseResult<?> ok(T data) {\r\n        this.data = data;\r\n        return this;\r\n    }\r\n\r\n    public Integer getCode() {\r\n        return code;\r\n    }\r\n\r\n    public void setCode(Integer code) {\r\n        this.code = code;\r\n    }\r\n\r\n    public String getMsg() {\r\n        return msg;\r\n    }\r\n\r\n    public void setMsg(String msg) {\r\n        this.msg = msg;\r\n    }\r\n\r\n    public T getData() {\r\n        return data;\r\n    }\r\n\r\n    public void setData(T data) {\r\n        this.data = data;\r\n    }\r\n    \r\n}\r\n~~~~\r\n\r\n~~~~java\r\n// 搭配使用\r\npublic enum AppHttpCodeEnum {\r\n    // 成功\r\n    SUCCESS(200, \"操作成功\"),\r\n    // 登录\r\n    NEED_LOGIN(401, \"需要登录后操作\"),\r\n    NO_OPERATOR_AUTH(403, \"无权限操作\"),\r\n    SYSTEM_ERROR(500, \"出现错误\"),\r\n    USERNAME_EXIST(501, \"用户名已存在\"),\r\n    REQUIRE_USERNAME(504, \"必需填写用户名\"),\r\n    LOGIN_ERROR(505, \"用户名或密码错误\");\r\n    int code;\r\n    String msg;\r\n\r\n    AppHttpCodeEnum(int code, String errorMessage) {\r\n        this.code = code;\r\n        this.msg = errorMessage;\r\n    }\r\n\r\n    public int getCode() {\r\n        return code;\r\n    }\r\n\r\n    public String getMsg() {\r\n        return msg;\r\n    }\r\n}\r\n~~~~\r\n\r\n### 三、redis\r\n\r\n学完redis才是本次重构后端的一大动力，因为感觉学完没写点东西，就觉得有点亏，加了redis后应该会对访问速度有点提升。不过也不一定，毕竟我的数据量那么小。\r\n\r\n~~~xml\r\n  redis:\r\n    database: 0\r\n    host: 127.0.0.1\r\n    jedis:\r\n      pool:\r\n        max-active: 20\r\n        max-idle: 10\r\n        max-wait: -1\r\n        min-idle: 0\r\n    password: \'******\'\r\n    port: 6379\r\n    timeout: 1000\r\n\r\nmybatis-plus:\r\n  configuration:\r\n    log-impl: org.apache.ibatis.logging.nologging.NoLoggingImpl\r\n  global-config:\r\n    db-config:\r\n      logic-delete-field: delFlag\r\n      logic-delete-value: 1\r\n      logic-not-delete-value: 0\r\n      id-type: auto\r\n~~~\r\n\r\n~~~~java\r\n@Configuration\r\npublic class RedisConfig {\r\n\r\n    @Bean\r\n    @SuppressWarnings(value = { \"unchecked\", \"rawtypes\" })\r\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\r\n    {\r\n        RedisTemplate<Object, Object> template = new RedisTemplate<>();\r\n        template.setConnectionFactory(connectionFactory);\r\n\r\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\r\n\r\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\r\n        template.setKeySerializer(new StringRedisSerializer());\r\n        template.setValueSerializer(serializer);\r\n\r\n        // Hash的key也采用StringRedisSerializer的序列化方式\r\n        template.setHashKeySerializer(new StringRedisSerializer());\r\n        template.setHashValueSerializer(serializer);\r\n\r\n        template.afterPropertiesSet();\r\n        return template;\r\n    }\r\n}\r\n~~~~\r\n\r\n~~~java\r\n@Component\r\npublic class RedisCache\r\n{\r\n    @Autowired\r\n    public RedisTemplate redisTemplate;\r\n\r\n    /**\r\n     * 缓存基本的对象，Integer、String、实体类等\r\n     *\r\n     * @param key 缓存的键值\r\n     * @param value 缓存的值\r\n     */\r\n    public <T> void setCacheObject(final String key, final T value)\r\n    {\r\n        redisTemplate.opsForValue().set(key, value);\r\n    }\r\n\r\n    /**\r\n     * 缓存基本的对象，Integer、String、实体类等\r\n     *\r\n     * @param key 缓存的键值\r\n     * @param value 缓存的值\r\n     * @param timeout 时间\r\n     * @param timeUnit 时间颗粒度\r\n     */\r\n    public <T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\r\n    {\r\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\r\n    }\r\n\r\n    /**\r\n     * 设置有效时间\r\n     *\r\n     * @param key Redis键\r\n     * @param timeout 超时时间\r\n     * @return true=设置成功；false=设置失败\r\n     */\r\n    public boolean expire(final String key, final long timeout)\r\n    {\r\n        return expire(key, timeout, TimeUnit.SECONDS);\r\n    }\r\n\r\n    /**\r\n     * 设置有效时间\r\n     *\r\n     * @param key Redis键\r\n     * @param timeout 超时时间\r\n     * @param unit 时间单位\r\n     * @return true=设置成功；false=设置失败\r\n     */\r\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\r\n    {\r\n        return redisTemplate.expire(key, timeout, unit);\r\n    }\r\n\r\n    /**\r\n     * 获得缓存的基本对象。\r\n     *\r\n     * @param key 缓存键值\r\n     * @return 缓存键值对应的数据\r\n     */\r\n    public <T> T getCacheObject(final String key)\r\n    {\r\n        ValueOperations<String, T> operation = redisTemplate.opsForValue();\r\n        return operation.get(key);\r\n    }\r\n\r\n    /**\r\n     * 删除单个对象\r\n     *\r\n     * @param key\r\n     */\r\n    public boolean deleteObject(final String key)\r\n    {\r\n        return redisTemplate.delete(key);\r\n    }\r\n\r\n    /**\r\n     * 删除集合对象\r\n     *\r\n     * @param collection 多个对象\r\n     * @return\r\n     */\r\n    public long deleteObject(final Collection collection)\r\n    {\r\n        return redisTemplate.delete(collection);\r\n    }\r\n\r\n    /**\r\n     * 缓存List数据\r\n     *\r\n     * @param key 缓存的键值\r\n     * @param dataList 待缓存的List数据\r\n     * @return 缓存的对象\r\n     */\r\n    public <T> long setCacheList(final String key, final List<T> dataList)\r\n    {\r\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\r\n        return count == null ? 0 : count;\r\n    }\r\n\r\n    /**\r\n     * 获得缓存的list对象\r\n     *\r\n     * @param key 缓存的键值\r\n     * @return 缓存键值对应的数据\r\n     */\r\n    public <T> List<T> getCacheList(final String key)\r\n    {\r\n        return redisTemplate.opsForList().range(key, 0, -1);\r\n    }\r\n\r\n    /**\r\n     * 缓存Set\r\n     *\r\n     * @param key 缓存键值\r\n     * @param dataSet 缓存的数据\r\n     * @return 缓存数据的对象\r\n     */\r\n    public <T> BoundSetOperations<String, T> setCacheSet(final String key, final Set<T> dataSet)\r\n    {\r\n        BoundSetOperations<String, T> setOperation = redisTemplate.boundSetOps(key);\r\n        Iterator<T> it = dataSet.iterator();\r\n        while (it.hasNext())\r\n        {\r\n            setOperation.add(it.next());\r\n        }\r\n        return setOperation;\r\n    }\r\n\r\n    /**\r\n     * 获得缓存的set\r\n     *\r\n     * @param key\r\n     * @return\r\n     */\r\n    public <T> Set<T> getCacheSet(final String key)\r\n    {\r\n        return redisTemplate.opsForSet().members(key);\r\n    }\r\n\r\n    /**\r\n     * 缓存Map\r\n     *\r\n     * @param key\r\n     * @param dataMap\r\n     */\r\n    public <T> void setCacheMap(final String key, final Map<String, T> dataMap)\r\n    {\r\n        if (dataMap != null) {\r\n            redisTemplate.opsForHash().putAll(key, dataMap);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获得缓存的Map\r\n     *\r\n     * @param key\r\n     * @return\r\n     */\r\n    public <T> Map<String, T> getCacheMap(final String key)\r\n    {\r\n        return redisTemplate.opsForHash().entries(key);\r\n    }\r\n\r\n    /**\r\n     * 往Hash中存入数据\r\n     *\r\n     * @param key Redis键\r\n     * @param hKey Hash键\r\n     * @param value 值\r\n     */\r\n    public <T> void setCacheMapValue(final String key, final String hKey, final T value)\r\n    {\r\n        redisTemplate.opsForHash().put(key, hKey, value);\r\n    }\r\n\r\n    /**\r\n     * 获取Hash中的数据\r\n     *\r\n     * @param key Redis键\r\n     * @param hKey Hash键\r\n     * @return Hash中的对象\r\n     */\r\n    public <T> T getCacheMapValue(final String key, final String hKey)\r\n    {\r\n        HashOperations<String, String, T> opsForHash = redisTemplate.opsForHash();\r\n        return opsForHash.get(key, hKey);\r\n    }\r\n\r\n    /**\r\n     * 删除Hash中的数据\r\n     * \r\n     * @param key\r\n     * @param hkey\r\n     */\r\n    public void delCacheMapValue(final String key, final String hkey)\r\n    {\r\n        HashOperations hashOperations = redisTemplate.opsForHash();\r\n        hashOperations.delete(key, hkey);\r\n    }\r\n\r\n    /**\r\n     * 获取多个Hash中的数据\r\n     *\r\n     * @param key Redis键\r\n     * @param hKeys Hash键集合\r\n     * @return Hash对象集合\r\n     */\r\n    public <T> List<T> getMultiCacheMapValue(final String key, final Collection<Object> hKeys)\r\n    {\r\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\r\n    }\r\n\r\n    /**\r\n     * 获得缓存的基本对象列表\r\n     *\r\n     * @param pattern 字符串前缀\r\n     * @return 对象列表\r\n     */\r\n    public Collection<String> keys(final String pattern)\r\n    {\r\n        return redisTemplate.keys(pattern);\r\n    }\r\n}\r\n~~~\r\n\r\n### 四、Mybatis-plus\r\n\r\n因为是主流框架，所以学了然后也用上了，配合idea里面的插件Easy code一键生成mapper，entity、service、serviceImpl简直不要太爽，开发效率大大提升。\r\n\r\n~~~java\r\n//配置类\r\n@Configuration\r\npublic class MybatisPlusConfig {\r\n\r\n    /**\r\n     * 3.4.0之后版本\r\n     * @return\r\n     */\r\n    @Bean\r\n    public MybatisPlusInterceptor mybatisPlusInterceptor(){\r\n        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();\r\n        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());\r\n        return mybatisPlusInterceptor;\r\n    }\r\n}\r\n~~~\r\n\r\n### 五、展望\r\n\r\n时间问题，加上各种各样的问题，我把留言部分砍掉了，这里里面关系有一点点小复杂，我就跑路了，后续应该会再加上留言板和具体博客下面的回复功能。剩下的时间那就刷刷题，背背八股文吧！！\r\n对了，博客上的图片都是引入的知乎回答的图片链接，因为我还没有做图片上传再引入博客内容的功能，哈哈哈，我真是大聪明！！！', '2022-04-03 11:19:42', '我只有在emo的时候文笔才会好点哈哈哈', 'https://pic3.zhimg.com/80/v2-d7dae9df4a73db4addde3d56526b745f_1440w.jpg', '原创', 1, 1, '重构博客后端的小收获', '2022-04-03 11:23:37', 127, 3, 1);

-- ----------------------------
-- Table structure for t_blog_tags
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tags`;
CREATE TABLE `t_blog_tags`  (
  `blogs_id` bigint(20) NOT NULL,
  `tags_id` bigint(20) NOT NULL,
  INDEX `FK5feau0gb4lq47fdb03uboswm8`(`tags_id`) USING BTREE,
  INDEX `FKh4pacwjwofrugxa9hpwaxg6mr`(`blogs_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_tags
-- ----------------------------
INSERT INTO `t_blog_tags` VALUES (15, 5);
INSERT INTO `t_blog_tags` VALUES (14, 7);
INSERT INTO `t_blog_tags` VALUES (10, 3);
INSERT INTO `t_blog_tags` VALUES (9, 3);
INSERT INTO `t_blog_tags` VALUES (8, 3);
INSERT INTO `t_blog_tags` VALUES (7, 3);
INSERT INTO `t_blog_tags` VALUES (6, 3);
INSERT INTO `t_blog_tags` VALUES (5, 3);
INSERT INTO `t_blog_tags` VALUES (4, 5);
INSERT INTO `t_blog_tags` VALUES (2, 3);
INSERT INTO `t_blog_tags` VALUES (18, 5);
INSERT INTO `t_blog_tags` VALUES (18, 7);
INSERT INTO `t_blog_tags` VALUES (20, 7);
INSERT INTO `t_blog_tags` VALUES (1795514317, 4);
INSERT INTO `t_blog_tags` VALUES (279665314, 8);

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (2, 'UI');
INSERT INTO `t_tag` VALUES (3, 'C语言');
INSERT INTO `t_tag` VALUES (4, 'Java');
INSERT INTO `t_tag` VALUES (5, '问题');
INSERT INTO `t_tag` VALUES (7, '一个句子');
INSERT INTO `t_tag` VALUES (8, 'useless');

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES (2, '今天又想说');
INSERT INTO `t_type` VALUES (3, '代码');
INSERT INTO `t_type` VALUES (4, '数字图像处理');

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type` int(11) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (1, '/images/myavatar.jpg', '2021-07-18 10:24:39', 'fanfun1120@qq.com', '范浩', '1120qweasd', 1, '2021-07-18 10:24:39', 'fanfun');

SET FOREIGN_KEY_CHECKS = 1;
